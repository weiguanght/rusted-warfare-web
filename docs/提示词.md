你需要扮演“项目经理”的角色，把任务切分成极小的方块，并且每次只给AI喂它当前需要的“原料（Java源码片段）”。

以下我为你整理的一套**分阶段 Prompt（提示词）清单**。你可以按顺序直接复制这些话发给AI。

---

### ⚠️ 在开始之前：通用规则 (每次对话前必读)

在开始任何代码生成之前，请先发送这条**“系统设定”**，这能防止AI写出不可用的代码：

> **系统设定 Prompt：**
> “我们要基于 Typescript + PixiJS + Web Worker 复刻 Java 游戏《铁锈战争》。
> **核心原则：**
> 1. **确定性 (Determinism)**：绝对禁止使用 JS 原生的 `number` 进行逻辑运算（如坐标、伤害）。必须使用我提供的 `Fixed` (定点数) 类。
> 2. **逻辑渲染分离**：所有逻辑代码（运算、状态更新）不能包含任何 DOM、Canvas 或 PixiJS 代码。逻辑必须能在 Web Worker 中独立运行。
> 3. **参考文件**：请依据我上传的 `Java-sourcecode_core_merged.txt` 理解原版逻辑，依据 `mappings.txt` 理解混淆名，依据 `架构参考.txt` 编写架构。
> 4. **代码风格**：使用严格类型的 TypeScript，每一行关键逻辑都要写注释。”

---

### 第一阶段：数学地基 (Foundation)

这是最枯燥但最重要的一步。如果没有这个，后面的坦克都会乱飞。

**任务目标**：建立定点数数学库。
**参考 Java 路径**：`com.corrodinggames.rts.gameFramework.f` (Math utils), `com.corrodinggames.rts.gameFramework.utility.y` (Trig lookup).

> **Prompt 1 (生成数学库)：**
> “请阅读 `Java-sourcecode_core_merged.txt` 中关于数学运算的部分（主要是 `com.corrodinggames.rts.gameFramework.f` 类）。
>
> 我需要你用 TypeScript 写一个 `Fixed` 类（定点数数学库）。
> **要求：**
> 1. 使用整数（Int32）模拟小数，倍率为 65536（1.0 = 65536）。
> 2. 实现加减乘除 (`add`, `sub`, `mul`, `div`)。
> 3. 实现一个 `sin` 和 `cos` 方法，**必须使用查表法 (Look-up Table)** 模拟原版 Java 的逻辑，不要使用 `Math.sin`。
> 4. 实现一个 `Vector2` 类，其中的 x, y 都是 `Fixed` 类型。
> 5. 写好后，请给我写一个简单的测试用例，证明 `Fixed.mul(1.5, 2.0)` 等于 `3.0`。”

---

### 第二阶段：游戏循环与状态 (The Loop)

有了数学，我们需要让时间流动起来。

**任务目标**：建立主循环，实现逻辑帧和渲染帧的分离。
**参考 Java 路径**：`com.corrodinggames.rts.gameFramework.l` (GameEngine - run/update/draw).

> **Prompt 2 (生成主循环)：**
> “现在我们需要构建游戏的核心循环。参考 `Java-sourcecode_core_merged.txt` 中的 `GameEngine` 类，但要剥离所有图形绘制代码。
>
> 请用 TypeScript 写出 `SimulationLoop` 类。
> **要求：**
> 1. 这是一个运行在 Web Worker 里的类。
> 2. 它有一个 `tick()` 方法，模拟固定的逻辑帧率（比如每秒 15 帧）。
> 3. 定义一个 `GameState` 接口，包含当前帧数 (`frameStep`) 和所有单位的列表。
> 4. 不要使用 `setTimeout`，请写一个基于 `performance.now()` 的累积时间累加器（Accumulator）逻辑来触发 `tick()`。
> 5. 在 `tick()` 里预留一个位置写注释：`// TODO: 更新所有单位逻辑`。”

---

### 第三阶段：单位的基础 (The Unit)

这是最复杂的。我们先只做一个只会发呆的坦克。

**任务目标**：复刻 `BaseUnit` 的核心属性（血量、位置、方向）。
**参考 Java 路径**：`com.corrodinggames.rts.game.units.am` (BaseUnit), `w` (GameObject).

> **Prompt 3 (生成单位基类)：**
> “参考 `Java-sourcecode_core_merged.txt` 中的 `com.corrodinggames.rts.game.units.am` (BaseUnit) 和 `w` (GameObject)。
>
> 请用 TypeScript 写一个 `BaseUnit` 类。
> **要求：**
> 1. 所有坐标 (x, y, z)、方向 (dir)、速度 (speed) 都要使用第一步写的 `Fixed` 类型。
> 2. 包含基础属性：id, hp, maxHp, team。
> 3. 包含一个 `update(deltaTime)` 方法。
> 4. **严禁移植渲染代码**：原版 Java 里的 `draw()` 方法完全抛弃，不要写进这个类里。
> 5. 实现简单的物理推挤逻辑接口（暂不填充具体算法，只留方法名 `solveCollisions`）。”

---

### 第四阶段：移动与寻路 (Movement)

让坦克动起来。

**任务目标**：实现从 A 走到 B 的逻辑。
**参考 Java 路径**：`com.corrodinggames.rts.game.units.y` (UnitEntity - movement logic), `com.corrodinggames.rts.gameFramework.k.l` (PathEngine).

> **Prompt 4 (移动逻辑)：**
> “参考 `Java-sourcecode_core_merged.txt` 中的 `com.corrodinggames.rts.game.units.y` (UnitEntity) 关于移动的逻辑。
>
> 请在刚才的 `BaseUnit` 中扩展移动功能：
> **要求：**
> 1. 添加 `moveTo(targetX: Fixed, targetY: Fixed)` 方法。
> 2. 在 `update` 中实现：
>    - 计算当前角度与目标角度的差值。
>    - 根据 `turnSpeed` (转弯速度) 逐步旋转单位（使用定点数计算）。
>    - 当角度对准后，根据 `acceleration` (加速度) 增加速度。
>    - 更新 x, y 坐标。
> 3. 所有的数学运算必须调用 `Fixed` 库。”

---

### 第五阶段：渲染显示 (Rendering)

只有逻辑是不够的，我们需要看到它。

**任务目标**：把逻辑数据同步给 PixiJS 显示出来。
**参考 Java 路径**：无（这部分完全重写，参考 `架构参考.txt` 的 renderer 部分）。

> **Prompt 5 (渲染器)：**
> “我们现在要把逻辑显示出来。请参考 `架构参考.txt` 的 UI/Renderer 部分。
>
> 请用 TypeScript + PixiJS 写一个 `GameRenderer` 类。
> **要求：**
> 1. 它运行在主线程。
> 2. 它可以接收来自 Worker 的 `GameState` 数据包（包含所有单位的 ID, x, y, dir）。
> 3. 维护一个 `Map<UnitID, PIXI.Sprite>`。
>    - 如果数据包里有新 ID -> 创建 Sprite。
>    - 如果数据包里 ID 消失 -> 删除 Sprite。
>    - 如果 ID 存在 -> 更新 Sprite 的 x, y, rotation。
> 4. 实现简单的插值（Interpolation）：因为逻辑帧只有 15 帧，渲染是 60 帧，请让 Sprite 在两个逻辑位置之间平滑移动。”
