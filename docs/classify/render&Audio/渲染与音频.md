基于我对《铁锈战争》源码（尤其是 `GameEngine` 即 `l.java` 和 `GraphicsEngine` 即 `y.java`）的分析，我为你提取了核心的渲染与音频规则，并转化为 TypeScript 实现方案。

-----

### 一、 坐标转换系统 (Coordinate System)

在源码中，`l.java` (GameEngine) 维护了两个坐标系：

1.  **游戏世界坐标 (World Coordinates)**: `x`, `y` (float 类型，逻辑单位，像素级)。
2.  **屏幕坐标 (Screen Coordinates)**: 渲染时使用。

核心变量（在 `l.java` 中）：

  * `cw`, `ch`: 摄像机中心的世界坐标 (Camera World X/Y)。
  * `cV`: 当前缩放倍率 (Zoom Level)。

**TypeScript 实现 (`Camera.ts`):**

```typescript
// 简单的单例或静态类管理摄像机
export class Camera {
  // 摄像机在世界地图的中心点
  public static x: number = 0;
  public static y: number = 0;
  
  // 缩放倍率 (1.0 = 100%)
  public static zoom: number = 1.0;

  // 视口宽高 (Canvas大小)
  public static width: number = window.innerWidth;
  public static height: number = window.innerHeight;

  /**
   * 将世界坐标转换为屏幕坐标 (用于渲染)
   * 对应源码中常见的: (x - cx + offsetX) * zoom
   */
  public static worldToScreen(worldX: number, worldY: number): { x: number, y: number } {
    // 屏幕中心偏移量
    const halfScreenW = this.width / 2;
    const halfScreenH = this.height / 2;

    const screenX = (worldX - this.x) * this.zoom + halfScreenW;
    const screenY = (worldY - this.y) * this.zoom + halfScreenH;

    return { x: screenX, y: screenY };
  }

  /**
   * 将屏幕坐标转换为世界坐标 (用于鼠标点击判定)
   */
  public static screenToWorld(screenX: number, screenY: number): { x: number, y: number } {
    const halfScreenW = this.width / 2;
    const halfScreenH = this.height / 2;

    const worldX = (screenX - halfScreenW) / this.zoom + this.x;
    const worldY = (screenY - halfScreenH) / this.zoom + this.y;

    return { x: worldX, y: worldY };
  }
}
```

-----

### 二、 渲染层级与 Z-Ordering (Rendering)

在源码 `l.java` 的 `draw()` 方法中，绘制顺序是严格硬编码的，以确保遮挡关系正确。

**原版绘制顺序规则：**

1.  **地图层 (Map Layer)**: 地面纹理、焦土痕迹。
2.  **尸体/残骸 (Corpses)**: 死亡单位 (`mode == dead`)。
3.  **地面单位 (Ground Units)**: 坦克、建筑。**注意：此处需要按 Y 轴排序实现伪 3D 遮挡。**
4.  **阴影 (Shadows)**: 所有单位的阴影（通常统一绘制或随单位绘制但有 offset）。
5.  **树木/地形物体 (Map Objects)**: 树木可能会遮挡地面单位（如果在单位下方）。
6.  **空军单位 (Air Units)**: 飞机、飞船。
7.  **特效 (Effects)**: 爆炸、烟雾、弹道。
8.  **UI/迷雾 (UI & Fog)**: 战争迷雾、选中框、血条、UI 控件。

**PixiJS 实现方案 (`RenderLayer.ts`):**

在 PixiJS 中，我们使用 `Container` 来作为层级，利用 `zIndex` 和 `sortableChildren` 来处理同层遮挡。

```typescript
import * as PIXI from 'pixi.js';

export class RenderManager {
  public app: PIXI.Application;
  
  // 定义层级容器
  public mapLayer: PIXI.Container;
  public groundLayer: PIXI.Container; // 包含尸体、地面单位、树木
  public airLayer: PIXI.Container;
  public effectLayer: PIXI.Container;
  public uiLayer: PIXI.Container;

  constructor(app: PIXI.Application) {
    this.app = app;

    // 1. 初始化容器
    this.mapLayer = new PIXI.Container();
    
    // 地面层需要开启排序，因为坦克和树木之间存在遮挡关系
    this.groundLayer = new PIXI.Container();
    this.groundLayer.sortableChildren = true; 
    
    this.airLayer = new PIXI.Container();
    this.effectLayer = new PIXI.Container();
    this.uiLayer = new PIXI.Container();

    // 2. 按顺序添加到舞台
    this.app.stage.addChild(this.mapLayer);
    this.app.stage.addChild(this.groundLayer);
    this.app.stage.addChild(this.airLayer);
    this.app.stage.addChild(this.effectLayer);
    this.app.stage.addChild(this.uiLayer);
  }

  /**
   * 每帧调用，更新单位位置和层级
   */
  public updateUnitRender(unitSprite: PIXI.Sprite, unitData: any) {
    // 转换坐标
    const screenPos = Camera.worldToScreen(unitData.x, unitData.y);
    unitSprite.x = screenPos.x;
    unitSprite.y = screenPos.y;

    // --- 核心规则：Y-Sorting (伪3D遮挡) ---
    // 在 PixiJS 中，zIndex 越大越靠前。
    // 在 2D 游戏中，Y 坐标越大的物体越靠近屏幕底部，应该遮挡 Y 坐标小的物体。
    // 所以直接用 screenY 作为 zIndex 即可。
    if (unitData.isGroundUnit || unitData.isBuilding) {
        unitSprite.zIndex = unitData.y; // 使用世界坐标Y作为排序依据更稳定
    }
  }
}
```

-----

### 三、 队伍颜色 (Team Coloring) - Shader 实现

原版 Java 代码中，单位素材通常是绿色的（或其他底色），然后通过像素操作或 PorterDuff 滤镜将特定颜色替换为队伍颜色（红、蓝等）。

在 Web 端，遍历像素太慢。最好的方法是写一个 **PixiJS Fragment Shader (片元着色器)**。

**原理：**
假设素材中设定 **纯绿色 (0, 255, 0)** 为“队伍色区域”。Shader 检测到像素是绿色时，将其替换为 `uTeamColor`，否则保持原样。

**TypeScript/PixiJS Shader 实现 (`TeamColorFilter.ts`):**

```typescript
import * as PIXI from 'pixi.js';

// GLSL 片元着色器代码
const fragmentShader = `
  varying vec2 vTextureCoord;
  uniform sampler2D uSampler;
  uniform vec3 uTeamColor; // 传入的队伍颜色 (R, G, B) 范围 0.0 - 1.0

  void main(void) {
    vec4 color = texture2D(uSampler, vTextureCoord);

    // --- 颜色替换逻辑 ---
    // 假设原始素材中，队伍部分是纯绿色 (R=0, G=1, B=0)
    // 我们设定一个阈值来检测这种颜色
    
    // 如果绿色分量很高，且红蓝分量很低，则认为是队伍色区域
    if (color.g > 0.5 && color.r < 0.4 && color.b < 0.4) {
       // 保留原始的 Alpha 通道，混合原图的明暗度(简单乘法)
       // color.g 是原图绿色的亮度，用来做明暗保留
       gl_FragColor = vec4(uTeamColor.r * color.g, uTeamColor.g * color.g, uTeamColor.b * color.g, color.a);
    } else {
       // 非队伍色区域，直接输出原色
       gl_FragColor = color;
    }
  }
`;

export function createTeamColorFilter(teamId: number): PIXI.Filter {
  // 定义队伍颜色映射 (归一化到 0-1)
  const teamColors: { [key: number]: [number, number, number] } = {
    0: [0.0, 1.0, 0.0], // 观察者/中立 (绿)
    1: [1.0, 0.0, 0.0], // 队1 (红)
    2: [0.0, 0.0, 1.0], // 队2 (蓝)
    3: [1.0, 1.0, 0.0], // 队3 (黄)
  };

  const color = teamColors[teamId] || [1.0, 1.0, 1.0];

  // 创建 Uniforms
  const uniforms = {
    uTeamColor: new Float32Array(color), // 传入 RGB
  };

  return new PIXI.Filter(undefined, fragmentShader, uniforms);
}
```

*使用方式：* `unitSprite.filters = [createTeamColorFilter(unit.teamId)];`

-----

### 四、 音频 3D 空间化 (Audio Spatialization)

原版 `SoundEngine` (`com.corrodinggames.rts.gameFramework.a.e`) 的逻辑很简单。它不使用复杂的 HRTF，只调节 **Volume (音量)** 和 **Pan (左右声道)**。

**原版逻辑提取：**

1.  **距离计算**: `dist = sqrt((unitX - cameraX)^2 + (unitY - cameraY)^2)`
2.  **音量衰减**: 这是一个反比函数，距离越远音量越小。`vol = baseVol / (1 + dist * attenuationFactor)`。
3.  **左右声道 (Pan)**: `pan = (unitX - cameraX) / (screenWidth / 2)`。结果限制在 -1 (左) 到 1 (右) 之间。

**TypeScript/Howler.js 实现 (`AudioManager.ts`):**

Howler 自带了 `stereo()` 方法，非常适合这种简单的 2D 空间化。

```typescript
import { Howl } from 'howler';
import { Camera } from './Camera';

export class AudioManager {
  private static sounds: { [key: string]: Howl } = {};

  // 加载音效
  public static loadSound(name: string, src: string) {
    this.sounds[name] = new Howl({ src: [src] });
  }

  /**
   * 播放 3D 音效
   * @param name 音效名称
   * @param x 音源的世界坐标 X
   * @param y 音源的世界坐标 Y
   */
  public static playSound3D(name: string, x: number, y: number) {
    const sound = this.sounds[name];
    if (!sound) return;

    // 1. 获取摄像机中心点 (听众位置)
    // 这里的 Camera.x/y 应该是摄像机中心在世界坐标的位置
    const listenerX = Camera.x;
    const listenerY = Camera.y;
    
    // 2. 计算距离 (像素单位)
    const dx = x - listenerX;
    const dy = y - listenerY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // 3. 计算音量衰减
    // 假设 1000 像素外听不到 (根据游戏视口调整参数)
    const maxDistance = 1500; 
    if (distance > maxDistance) return; // 太远不播放

    // 线性衰减或指数衰减均可，这里用简单的线性模拟
    // 距离 0 -> 音量 1.0; 距离 max -> 音量 0.0
    let volume = 1.0 - (distance / maxDistance);
    if (volume < 0) volume = 0;

    // 4. 计算立体声 (Pan)
    // 将屏幕宽度的一半作为 "满左" 或 "满右" 的基准
    // dx 为负表示在左边，正表示在右边
    const visibleWidth = Camera.width / Camera.zoom;
    let pan = dx / (visibleWidth / 2);
    
    // 限制在 -1 到 1 之间
    pan = Math.max(-1, Math.min(1, pan));

    // 5. 播放
    const id = sound.play();
    sound.volume(volume, id);
    sound.stereo(pan, id);
  }
}
```

### 总结与下一步

1.  **坐标系**: 建立了 `worldToScreen` 的基础。
2.  **渲染**: 使用 PixiJS `Container` 分层，并在 `GroundLayer` 使用 `zIndex = y` 解决遮挡。
3.  **上色**: 使用 GLSL Fragment Shader 替换原版的像素处理，性能极高。
4.  **音频**: 将简单的距离和位置差映射到 Howler 的 `volume` 和 `stereo`。
