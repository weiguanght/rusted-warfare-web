基于你提供的源码（特别是 `Java-sourcecode_core_merged.txt` 中涉及 `k` 包和地图运算的部分），《铁锈战争》的寻路系统（Pathfinding System）设计得非常实用且高效，专门针对**低性能设备**和**海量单位**（万人同屏）进行了优化。

该系统并没有使用极其复杂的现代导航网格（NavMesh），而是采用了经典的 **A* (A-Star) 算法结合物理推挤（Physics-based Repulsion）** 的方案。

以下是该部分的详细逻辑拆解：

---

### 寻路算法与移动系统架构 (Pathfinding & Movement Architecture)

#### 1. 地图的数据表达：网格化世界 (The Grid World)
为了进行寻路，游戏首先将连续的像素世界抽象为离散的“网格”。

* **TileMap (瓦片地图)**：
    * **逻辑**：整个地图被切割成无数个小方块（Tile）。例如，地图大小为 1000x1000 像素，每个网格可能是 20x20 像素。
    * **通行性矩阵 (Passability Matrix)**：
        * 内存中维护着一个二维数组，标记每个网格的“通行成本”。
        * `0` = 畅通无阻（平地）。
        * `Infinity` = 不可通行（深水、悬崖、墙壁）。
        * `High Cost` = 难行地形（如沼泽，虽然能走但会极大降低移动速度，寻路时会尽量避开）。
    * **动态更新 (Dynamic Updates)**：
        * 当玩家建造一座“炮塔”时，该建筑物占据的网格会立即从“可通行”变为“不可通行”。
        * 寻路系统是实时的，单位会意识到前面突然多了一堵墙，并重新计算路径。

#### 2. 宏观寻路：A* 算法 (Global Pathfinding: A*)
这是单位如何找到从地图左下角到右上角路线的核心逻辑。

* **PathEngine (路径引擎 - 类名通常混淆为 `l` 在 `k` 包下)**：
    * **任务**：输入起点 `(StartNode)` 和终点 `(EndNode)`，输出一个节点列表 `[Node1, Node2, Node3...]`。
    * **算法核心**：
        1.  **Open List (待检查列表)**：放入起点。
        2.  **循环计算**：取出成本最低的节点，检查其周围 8 个方向的邻居。
        3.  **G值与H值**：
            * `G值`：从起点走到当前格的实际代价。
            * `H值` (Heuristic)：当前格到终点的“预估距离”（通常使用曼哈顿距离或欧几里得距离）。
            * `F值 = G + H`：优先处理 F 值最小的路径。
        4.  **构建路径**：当搜索到终点时，回溯父节点，生成路径链。

* **性能优化策略 (关键)**：
    * **分时计算 (Timeslicing)**：为了防止几百个单位同时寻路导致手机卡死，引擎每一帧限制寻路请求的数量。如果请求过多，部分单位会排队等待几帧才开始移动。
    * **路径缓存**：如果多个单位要去同一个地方，或者最近刚计算过类似路径，直接复用结果。
    * **甚至放弃**：如果目标点完全被围死（如被建筑围住），算法会在搜索一定步数后提前终止，防止遍历整个地图造成卡顿。

#### 3. 微观移动：物理避让与软碰撞 (Local Avoidance & Soft Collision)
A* 算法只负责静态障碍物（山、河、建筑），它不管其他移动的单位。如果只用 A*，所有坦克会重叠在一起变成一个点。为了解决这个问题，游戏引入了物理层。

* **软碰撞圆 (Soft Circular Collision)**：
    * 每个单位都有一个 `radius`（半径）。
    * 在每一帧的 `update` 中，单位会检查周围一定范围内的其他单位。
    * **推挤逻辑 (Repulsion Force)**：
        * 如果 `距离 < (半径A + 半径B)`，说明发生了重叠。
        * 引擎会给两个单位施加一个反向的“力”，把它们推开。
        * 这是一个“软”碰撞，单位之间允许短暂的重叠，然后滑开。这比严格的刚体碰撞（Hard Collision）计算量小得多，且表现更流畅，像流体一样。

* **队形与群聚 (Formation & Flocking)**：
    * 当选中一队坦克移动时，它们并不是全都去同一个坐标点。
    * 逻辑层会计算出一个“目标区域”，并为每个坦克分配该区域内的一个独立偏移点（Offset），防止所有单位挤死在终点。

#### 4. 移动执行器 (Movement Executor)
有了路径和避让逻辑，`UnitEntity` 具体怎么动？

* **Waypoints (路点跟随)**：
    * 单位内部维护一个 `currentWaypoint` 指针。
    * **逻辑流程**：
        1.  算出当前坐标指向 `currentWaypoint` 的角度。
        2.  **转向**：根据 `turnSpeed`（转弯速度）逐渐调整机身朝向。重型单位转得慢，轻型单位转得快。
        3.  **加速**：当朝向大致对准目标时，施加加速度，直到达到 `maxSpeed`。
        4.  **到达判断**：当 `distance(self, waypoint) < 阈值` 时，视为到达，切换到下一个路点。

* **平滑处理 (Smoothing)**：
    * A* 算出来的路径是折线（锯齿状的）。
    * 游戏使用了**视线检查 (Line of Sight)** 优化：如果单位能直接直线走到“下下个路点”且中间没有障碍，它会跳过“下个路点”，直接走直线。这让单位的移动轨迹看起来更自然，而不是死板地走“之”字形。

#### 5. 特殊移动类型 (Movement Types)
源码中 `UnitMovementType` 枚举定义了不同的寻路规则：

* **LAND (陆军)**：遵循标准的 A*，避开水域和悬崖。
* **AIR (空军)**：
    * **逻辑**：完全忽略地形代价。
    * **寻路**：直接走直线（Beeline）。
    * **盘旋**：飞机的移动逻辑包含“最小转弯半径”，不能像坦克一样原地旋转，必须画圆圈掉头。
* **HOVER (悬浮)**：可以穿越水面和陆地，但不能穿越悬崖。
* **WATER (海军)**：只能在水域网格中寻路。
* **OVER_CLIFF (全地形)**：类似于蜘蛛机甲，可以跨越悬崖，逻辑上视为所有地形通行成本都很低。

### 总结图示 (Summary)

你可以把《铁锈战争》的寻路看作**两层系统**的叠加：

1.  **导航层 (GPS)**：
    * 负责“长途旅行”。
    * 使用 A* 算法。
    * 处理静态地形（山、海、房）。
    * 更新频率低（只在下达命令或环境改变时计算）。

2.  **驾驶层 (Driver)**：
    * 负责“当前这一步”。
    * 使用物理推挤力。
    * 处理动态障碍（友军坦克、敌军残骸）。
    * 更新频率高（每帧都在计算 `x += dx`）。

这种设计非常聪明。**A* 保证了单位不会迷路，物理推挤保证了单位不会重叠**。两者互不干扰，完美解决了 RTS 游戏中大规模单位移动的难题。
