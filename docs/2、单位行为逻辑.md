这是第二部分（单位行为逻辑）的完整结构逻辑翻译。这一部分是游戏内容的核心，定义了**单位属性（Unit Attributes）**、**行动（Actions）**、**攻击与移动（Combat & Movement）**以及高度灵活的**自定义单位（Custom Units）**系统。

---

### 第二部分：单位行为与自定义逻辑 (Unit Behavior & Customization)

这一部分代码实现了游戏中所有“可操作实体”的规则。它通过一个庞大的继承体系，从最基础的“存在物”扩展到复杂的“自定义战斗单位”。

#### 1. 单位继承体系 (Unit Inheritance Hierarchy)
这是游戏逻辑的骨架，从抽象到底层实现：

* **`GameObject` (游戏对象)**:
    * 所有物体的始祖。定义了 `id`、`位置 (x, y, z)`、`生命周期` 和 `基本更新/绘制` 接口。
* **`BaseUnit` (类名 `am` / `BaseUnit`)**:
    * **核心角色**: 这是所有“单位”的基类。无论是建筑、坦克还是虫子，只要有血条、能被选中，都继承自这里。
    * **核心属性**:
        * **生存**: `hp` (生命值), `shield` (护盾), `armor` (护甲), `team` (阵营), `dead` (死亡状态)。
        * **资源**: `credits` (造价), `mass` (质量/运输占用), `energy` (能量值)。
        * **状态**: `built` (建造进度), `stunned` (眩晕), `transporting` (运输中)。
    * **核心逻辑**: 碰撞检测、受击判定、死亡处理、简单的物理移动（如被击退）。
* **`UnitEntity` (类名 `y` / `UnitEntity`)** (继承自 `BaseUnit`):
    * **核心角色**: 这是“战斗单位”的实际实现类。
    * **行为**:
        * **移动 (Movement)**: 处理路径点 (`waypoints`)、转向 (`rotation`)、加速度 (`speed`)。
        * **攻击 (Combat)**: 处理炮塔旋转 (`turretRotation`)、开火冷却 (`cooldown`)、索敌 (`target`)。
        * **交互**: 包含路径寻路 (`Pathfinding`) 的接口调用。

#### 2. 指令与动作系统 (Command & Action System)
单位如何响应玩家操作？通过“动作”系统。

* **`UnitAction` / `UnitCommand` (类名 `au`, `s`)**:
    * **定义**: 每一个操作（移动到某点、攻击某人、建造某物）都被封装成一个 `UnitCommand`。
    * **类型**:
        * `move`: 移动。
        * `attack`: 强制攻击。
        * `build`: 建造。
        * `repair` / `reclaim`: 维修 / 回收。
        * `load` / `unload`: 装载 / 卸载。
    * **执行流程**: 玩家点击 -> 生成 Command -> 发送到服务器/主机 -> 主机广播 -> 所有客户端同步执行 -> 单位添加该指令到队列 -> 单位在 `update` 中执行指令。

#### 3. 自定义单位系统 (Custom Unit System) - 核心亮点
这是《铁锈战争》最强大的部分，它允许通过 `.ini` 文件创造几乎任何逻辑的单位。

* **`CustomUnit` (类名 `j` 在 `custom` 包下)**:
    * **角色**: 一个通用的“空壳”单位，它的所有属性（外观、血量、攻击方式）都由配置文件决定。
    * **实现**: 它继承自 `UnitEntity`，但重写了几乎所有方法，改为读取 `CustomUnitConfig` 中的数据。
* **`CustomUnitConfig` (类名 `l` 在 `custom` 包下)**:
    * **职责**: 解析 `.ini` 文件。它存储了单位的“蓝图”。
    * **解析内容**:
        * `[core]`: 基础属性（血量、价格）。
        * `[graphics]`: 图片路径、动画帧。
        * `[attack]`: 攻击范围、伤害、射速。
        * `[movement]`: 移动类型（陆地/空军/悬浮）。
        * `[turret_X]`: 定义多个炮塔及其位置、属性。
        * `[projectile_X]`: 定义子弹特性。
* **`LogicBoolean` (逻辑解析器)**:
    * **功能**: 这是一个内置的脚本语言解析器。
    * **工作方式**: 将字符串逻辑（如 `if self.hp < 100 and self.energy > 50`）转换为 Java 代码能理解的 `true/false`。
    * **应用**: 用于控制单位的动态行为，例如“只有在血量低时才开启护盾”或“只有在特定地形上才变形”。
* **`Action` & `ActionWithCost`**:
    * 定义了自定义的按钮操作（如“变身”、“发射核弹”、“传送”）。包含资源消耗检查、冷却时间管理。

#### 4. 寻路与移动逻辑 (Pathfinding & Movement)
* **`PathEngine` (类名 `l` 在 `k` 包下)**:
    * **A* 算法**: 用于计算从 A 到 B 的最短路径，避开障碍物（地形、建筑）。
    * **流场 (Flow Field) / 局部避让**: 单位不仅要跟随路径，还要互相避让（RVO），防止重叠。代码中包含大量的圆碰撞检测和推挤逻辑。
* **`UnitMovementType` (类名 `ao`)**:
    * 枚举了单位的移动类型：`LAND` (陆军), `AIR` (空军), `HOVER` (气垫), `WATER` (海军), `OVER_CLIFF` (跨越悬崖)。不同的类型决定了它能通过哪些地形。

#### 5. 攻击与伤害计算 (Combat & Damage)
* **`Projectile` (类名 `f` / `g`)**:
    * **实体**: 子弹、导弹、光束也是游戏对象 (`GameObject` 的子类)。
    * **逻辑**: 每一帧更新位置。当碰到单位时，触发伤害计算。
    * **属性**: 包含 速度、伤害值、AOE范围、特效引用、跟踪能力。
* **伤害公式**:
    * 基础伤害 - 目标护甲（如果有）。
    * 护盾吸收伤害（消耗能量）。
    * 对建筑/非建筑的伤害修正。

---

### 第二部分逻辑总结图示

**单位生命周期 (The Life of a Unit):**

1.  **Spawn (生成)**:
    * 从 `UnitType` (工厂) 实例化 `CustomUnit` 或 `UnitEntity`。
    * 读取 `.ini` 配置，初始化血量、图片、炮塔。
    * 加入 `GameEngine` 的对象列表。
2.  **Update (每帧循环)**:
    * **指令检查**: 队列里有命令吗？(移动? 攻击?)
    * **状态机**:
        * *Idle*: 扫描攻击范围内的敌人 (`searchTarget`)。
        * *Moving*: 调用 `PathEngine`，向下一个路径点移动像素。处理单位间推挤。
        * *Attacking*: 旋转炮塔 (`turretRotation`) -> 瞄准 -> 检查冷却 -> 发射 `Projectile`。
    * **脚本逻辑**: 检查 `autoTrigger` (自动触发器)，执行 `LogicBoolean` 判断。
3.  **Interaction (交互)**:
    * 被子弹击中 -> 扣血 (`hp -= damage`) -> 检查死亡 (`hp <= 0`)。
4.  **Death (死亡)**:
    * 播放爆炸特效 (`createEffect`)。
    * 生成残骸 (`createWreckage`)。
    * 从游戏循环中移除。

这就是游戏逻辑层的核心。它极度依赖数据驱动（Data-Driven），这意味着 Java 代码主要负责“解释规则”，而真正的游戏玩法（单位强弱、技能效果）几乎全在 `.ini` 文件中定义。
