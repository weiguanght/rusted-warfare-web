**第一部分：游戏主循环与基础对象 (The Game Loop & Basic Objects)** 的逻辑拆解。

这一部分是整个游戏的地基。如果没有这两者，游戏世界将不存在，也不会有时间流逝。根据反编译的源码（主要是 `GameEngine` 和 `GameObject` 对应的类），我将它们从 Java 代码翻译为以下的书面逻辑结构。

---

### 第一部分：游戏主循环与基础对象架构

#### 1. 中央处理器：游戏引擎 (GameEngine)
在源码中，这个类（通常混淆为 `l` 或直接名为 `GameEngine`）是绝对的权威，采用了**单例模式 (Singleton)** 设计。你可以把它想象成整个游戏的“大脑”或“上帝”。

**A. 全局唯一访问点 (The Singleton Instance)**
* **逻辑描述**：为了让游戏中的任何角落（无论是网络模块、单位逻辑还是UI界面）都能随时获取游戏状态，`GameEngine` 维护了一个静态的、全局唯一的自身的实例。
* **代码意图**：源码中存在一个静态方法（类似 `getInstance()` 或 `B()`），任何其他类调用这个方法时，都会得到同一个 `GameEngine` 对象。这确保了数据的一致性——游戏中不可能同时存在两个“世界”。

**B. 核心生命周期与主循环 (The Main Loop)**
这是引擎最核心的功能，它让游戏“动”起来。它包含两个并行的、但职责完全分离的循环过程：

1.  **逻辑更新循环 (`update` / `tick`)**：
    * **职责**：负责计算游戏世界的“下一刻”发生了什么。
    * **增量时间 (Delta Time)**：引擎会计算上一帧到当前帧经过了多少毫秒。这个时间差被传递给所有子系统，确保无论手机性能快慢，游戏内的单位移动速度由时间决定，而不是帧率决定（例如：坦克的速度是“每秒移动100像素”，而不是“每帧移动2像素”）。
    * **流程**：
        1.  检测用户输入（触摸、鼠标）。
        2.  更新网络状态（接收其他玩家指令）。
        3.  **遍历所有游戏对象**：命令地图上的每一个坦克、子弹、树木执行它们自己的更新逻辑。
        4.  碰撞检测处理。
        5.  清理已死亡的对象。

2.  **渲染绘制循环 (`draw` / `render`)**：
    * **职责**：负责把计算好的游戏世界画在屏幕上。
    * **流程**：
        1.  **清屏**：清除上一帧的图像。
        2.  **坐标变换**：根据摄像机（Camera）的位置，计算世界坐标到屏幕坐标的映射（处理地图的缩放和拖动）。
        3.  **绘制地图底层**：画地表、海洋。
        4.  **绘制对象**：遍历所有可见的对象，让它们画出自己。
        5.  **绘制迷雾**：覆盖战争迷雾。
        6.  **绘制UI**：在最上层画按钮、小地图、资源数字。

**C. 子系统容器 (The Subsystem Container)**
`GameEngine` 像一个容器，持有所有其他关键系统的引用。它在初始化 (`init`) 时，会按顺序启动以下模块：
* **设置管理器**：读取 `settings.ini`，加载音量、画质等配置。
* **网络控制器**：准备多人联机的 socket 连接。
* **音频引擎**：预加载音效和背景音乐。
* **图形引擎**：初始化 OpenGL 或 Canvas 上下文。

---

#### 2. 万物基类：游戏对象 (GameObject)
在源码中（通常混淆为 `w` 或 `GameObject`），这是所有存在于游戏地图上的实体的“父亲”。无论是威风凛凛的实验级机甲，还是一颗不起眼的石头，甚至是飞过的子弹，在代码底层本质上都是 `GameObject`。

**A. 空间存在性 (Spatial Existence)**
每个对象在逻辑上都必须存在于某个位置。源码定义了一套坐标系统：
* **X, Y 轴**：标准的 2D 平面坐标，决定了对象在地图上的位置。
* **Z 轴 (Height)**：虽然是 2D 游戏，但源码引入了“高度”概念。这使得飞机可以飞在坦克上方，子弹可以有抛物线轨迹，单位可以从高处跳下。
* **朝向 (Direction)**：一个 0 到 360 度的浮点数，决定了单位面向哪里。

**B. 核心行为契约 (The Behavior Contract)**
`GameObject` 定义了一系列**抽象的**行为，要求所有子类必须实现。这意味着它制定了“规则”，而具体的“执行”由子类（如坦克、建筑）完成。

1.  **`update(deltaTime)` 接口**：
    * 这是对象“思考”的地方。每一帧，引擎都会问对象：“在这个时间片段里，你要做什么？”
    * *例如：子弹会向前飞一段距离；坦克会旋转炮塔瞄准敌人；树木可能什么都不做。*

2.  **`draw(canvas)` 接口**：
    * 这是对象“展示”的地方。引擎告诉对象：“现在轮到你上镜了，把自己画出来。”
    * 对象会根据自己的当前位置 (x, y, z) 和朝向，选择正确的图片素材（Sprite）画在画布上。

**C. 身份与状态管理 (Identity & State)**
* **唯一 ID**：每个对象生成时都会被分配一个长整型 ID，用于网络同步（比如主机告诉客户端：“ID为 10086 的单位爆炸了”）。
* **生命状态**：
    * `dead` (死亡标记)：当单位血量归零，标记为死亡。
    * `remove` (移除标记)：当死亡动画播放完毕，或者对象不再需要时，标记为移除。引擎会在每一帧的末尾扫描这个标记，将对象从内存列表中彻底删除。

---

### 第一部分逻辑总结图示

你可以将这部分逻辑想象成一个**巨大的时钟齿轮（GameEngine）**和一个**对象列表（List of GameObjects）**的关系：

1.  **Tick (滴答)**：`GameEngine` 收到系统信号，新的一帧开始。
2.  **Input**：`GameEngine` 问：“玩家点屏幕了吗？” -> 存入指令队列。
3.  **Process**：`GameEngine` 拿着名单（对象列表），从头到尾点名。
    * 喊道：“坦克A！” -> 坦克A 算出自己向前走了 1 厘米。
    * 喊道：“子弹B！” -> 子弹B 算出自己撞到了 坦克A，造成伤害。
    * 喊道：“特效C！” -> 特效C 算出自己动画播完了，举手说“我可以删除了”。
4.  **Render**：`GameEngine` 擦黑板，根据最新位置把大家重新画一遍。
5.  **Loop**：回到第 1 步。

这就是《铁锈战争》代码运行的最底层逻辑。
