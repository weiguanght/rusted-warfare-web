#游戏逻辑

这是《铁锈战争》（Rusted Warfare）的核心逻辑。根据你提供的文件内容（game-Java-sourcecode_merged.txt）和混淆映射表（mappings.txt），我可以为你还原出清晰的架构设计，并开始系统性地解读各个模块。
由于代码经过混淆（变量名如 a, b, am 等），我将结合映射表（Mappings）还原其真实含义，以确保逻辑的可读性。

第一部分：架构设计 (Architecture Design)
基于源码分析，该游戏采用了经典的**主循环驱动（Game Loop）与面向对象（OOP）**相结合的架构。整体设计高度模块化，将引擎层与游戏逻辑层分离。
1. 核心层级结构
* GameEngine (l 类 / i 类扩展):
    * 这是整个游戏的“心脏”。它是一个单例（Singleton），负责管理整个生命周期。
    * 职责：主循环（Update/Draw）、输入处理（触摸/鼠标）、渲染器管理、网络同步锁步、文件IO。
    * 源码对应：com.corrodinggames.rts.game.i (扩展自 gameFramework.l)。
* Team System (n 类 - PlayerTeam):
    * 游戏支持多阵营/多玩家。每个玩家（无论是人类还是AI）都由一个 PlayerTeam 实例表示。
    * 职责：资源管理（资金 credits）、单位上限、战争迷雾（Fog of War）、同盟关系判断。
    * 源码对应：com.corrodinggames.rts.game.n。
* Unit Entity System (单位实体系统):
    * 采用继承树结构。
    * am (BaseUnit): 所有实体的基类。处理坐标（x, y, z）、碰撞盒、基础渲染、生命值。
    * y (OrderableUnit): 可接收命令的单位（如坦克、士兵）。处理路径搜索（Pathfinding）、指令队列、动作状态机。
    * as (UnitType): 享元模式（Flyweight Pattern）。定义单位的静态属性（造价、最大生命值、贴图），避免每个单位重复存储相同数据。
    * 源码对应：game.units.am, game.units.y, game.units.ar (枚举类型)。
* AI Controller (game.a.a - AIController):
    * 负责AI的高层决策。
    * 职责：经济管理、建造策略、进攻波次管理（Land/Air/Sea Attack Groups）。
    * 源码对应：com.corrodinggames.rts.game.a.a。
* Network & Synchronization (网络与同步):
    * 游戏采用**锁步同步（Lockstep）**机制。
    * 所有指令（Command）通过网络广播帧号，客户端在确定性逻辑下模拟游戏世界，确保所有人的游戏状态一致。

第二部分：核心模块逻辑解读 (第一辑)
我们先从最基础的**玩家/阵营管理（PlayerTeam）和游戏主控逻辑（GameLogic）**开始翻译和解析。
1. 玩家团队类 n.java (对应 PlayerTeam)
这个类是游戏状态的核心容器之一，管理着每个玩家的“资产”。
结构逻辑译文：
类定义： public abstract class n extends bq
* 继承关系：继承自 bq (GameObject)，意味着它也是游戏世界中的一个对象，可以被序列化和同步。
关键属性 (还原后)：
* int k -> teamId (队伍ID，0-9通常是玩家/AI，-1是观察者等)
* double o -> credits (当前资金/资源)
* int r -> teamColor (队伍颜色ID)
* boolean w -> isAI (是否为AI控制)
* int x -> aiDifficulty (AI难度)
* s T -> statistics (统计数据，如杀敌数、生产数)
* int L, M -> fogWidth, fogHeight (战争迷雾网格大小)
* byte[][] N -> fogMap (战争迷雾数据，记录哪些区域已探索)
核心方法逻辑：
1. 初始化与重置 (Z() / readIn()):
    * 当游戏开始或重置时，初始化资金为默认值（通常是4000或自定义）。
    * 设置起始单位（Command Center）。
    * 初始化迷雾数组 N，大小取决于地图尺寸。
2. 网络序列化 (b(as) / a(k)):
    * 写入：将资金、队伍ID、名称、同盟状态、迷雾数据打包写入网络流。
    * 读取：从网络包中恢复这些状态。这是断线重连和存读档的基础。
    * 逻辑细节：代码中使用了 if (version >= ...) 的判断，这是为了向后兼容旧版本的存档格式。
3. 资源管理 (d(float) / g(int)):
    * d(float amount): 增加资金。如果资金超过最大值（999999999），则截断。
    * g(int amount): 判断是否买得起某物（credits >= amount）。
4. 同盟与敌对 (c(n) / d(n)):
    * c(n otherTeam): 判断是否为敌人。逻辑：如果 this 或 otherTeam 是中立队伍（如野怪），则不是普通敌对关系；否则比较 teamId，不同则为敌。
    * d(n otherTeam): 判断是否为盟友。逻辑：如果是自己，或者同盟模式开启且队伍组别相同，则返回 true。
5. 战争迷雾 (d(as) / d(k)):
    * 这是一个比较重的逻辑。它将迷雾状态作为一个二维字节数组进行序列化。为了节省带宽，通常会进行压缩处理。

2. 游戏主逻辑类 i.java (对应 GameLogic / GameEngine 实现)
这是 GameEngine 的具体实现类，负责把控全局。
结构逻辑译文：
类定义： public class i extends com.corrodinggames.rts.gameFramework.l
* 核心地位：它是引擎的入口点。
关键属性 (还原后):
* bL (父类属性) -> map (当前加载的地图对象，包含地形、瓦片数据)
* bX (父类属性) -> networkEngine (网络管理器)
* bS (父类属性) -> interfaceEngine (UI界面管理器)
* bs -> playerTeam (当前本地玩家控制的队伍)
* float e -> gameSpeed (游戏速度倍率)
核心方法逻辑：
1. 初始化 (init(Context)):
    * 加载设置：读取 SettingsEngine，配置画质、音效。
    * 初始化子系统：依次启动音频引擎、图形引擎（OpenGL或Canvas）、网络引擎、路径搜索器（PathEngine）。
    * 加载资源：调用 Unit.loadAllUnits() 加载所有单位的定义文件（.ini）。这是模组（Mod）加载的关键点。
2. 游戏循环 (update(float delta) / draw(float delta)):
    * Update:
        * 更新网络状态（发送/接收锁步帧）。
        * 更新所有单位逻辑（移动、攻击）。
        * 更新特效（爆炸、烟雾）。
        * 更新弹道（Projectiles）。
        * 逻辑细节：代码中有防卡顿处理，如果逻辑帧耗时过长，会跳过渲染帧。
    * Draw:
        * 设置摄像机位置。
        * 绘制地图底层（地形）。
        * 绘制所有单位（按Y轴排序以处理遮挡关系）。
        * 绘制迷雾遮罩。
        * 绘制UI层（小地图、选兵框、资源文字）。
3. 地图加载 (b(boolean) / loadMap):
    * 解析 .tmx 地图文件。
    * 生成路径网格（Pathfinding Grid）。
    * 初始化所有玩家的起始位置和单位。

第三部分：单位系统解析 (第二辑)
这是游戏玩法的核心，定义了单位如何存在和交互。
3. 基础单位类 am.java (对应 BaseUnit)
逻辑结构：
1. 空间属性：
    * eo, ep, eq -> x, y, z (世界坐标。z轴用于处理飞行单位或潜艇)。
    * cg -> direction (朝向角度)。
    * radius -> collisionRadius (碰撞半径)。
2. 状态属性：
    * cu -> hp (当前生命值)。
    * cv -> maxHp (最大生命值)。
    * bV -> isDead (是否死亡标记)。
    * bX -> team (所属队伍引用)。
3. 核心逻辑：
    * update(float delta): 每帧调用。处理物理运动（速度加到坐标上）、生命值回复、护盾回复。
    * draw(): 根据当前位置和朝向，从图集中切片并绘制单位贴图。
    * setTeam(n team): 改变所属权（例如被感化或占领）。
4. 可命令单位类 y.java (对应 OrderableUnit)
继承自 BaseUnit，增加了复杂的行为控制。
逻辑结构：
1. 寻路与移动 (UnitMovement):
    * 包含一个 Waypoint 队列。
    * 逻辑：每帧检查是否有路径点。如果有，调用 PathEngine 计算下一步的移动向量，避开障碍物。
    * 细节：包含 move, attackMove, patrol 等不同移动模式的标志位。
2. 动作系统 (Action):
    * a(s action): 执行某个动作（如建造建筑、发射核弹）。
    * buildQueue: 生产队列。工厂类单位会有此属性，记录正在生产的单位列表和进度。
3. 攻击逻辑 (Attack):
    * R -> target (当前锁定的敌人)。
    * 逻辑：检查目标是否在射程（Range）内。如果在，旋转炮塔（如果有）对准目标；冷却时间（Cooldown）结束后，生成抛射物（Projectile）。
