# 《铁锈战争》寻路算法

### 1\. 核心架构设计：四层解耦体系

本系统采用高度工程化的分层架构，旨在解决**低性能移动设备**上的**万人同屏**寻路难题。系统核心哲学被概括为“宏观GPS导航（A\*） + 微观物理驾驶（Physics）”的双层模型。

#### 1.1 架构分层表

系统模块职责划分极其清晰，各层协同工作：

| 层级 | 类名/模块 | 核心职责 | 关键技术/模式 |
| :--- | :--- | :--- | :--- |
| **数据层 (Data)** | `TileMap` (`game.b.b`) | 维护网格化世界、通行矩阵、动态地形更新 | 空间哈希、状态位缓存 |
| **调度层 (Scheduler)** | `PathEngine` (`gameFramework.k.l`) | 全局资源分配、请求队列管理、线程调度 | 单例模式、时间切片、优先级队列 |
| **任务层 (Task)** | `PathRequest` (`gameFramework.k.k`) | 封装单次具体的 A\* 计算任务 | 对象池 (Object Pooling) |
| **执行层 (Executor)** | `OrderableUnit` (`game.units.y`) | 路径跟随、平滑处理、物理避障、队形控制 | 有限状态机 (FSM)、RVO 算法 |

-----

### 2\. 数据层：高精度的网格化世界

#### 2.1 地图离散化 (The Grid World)

  * **网格粒度**：地图被切割为固定尺寸的瓦片（Tile）。例如，一个 1000x1000 像素的地图被切割为 50x50 的网格，每个网格（如 20x20 像素）是算法的基本单元。
  * **坐标转换**：`TileMap` 提供 `a(x, y)` 接口，负责将世界坐标系（浮点数）转换为网格坐标系（整数），作为所有算法的入口。

#### 2.2 通行性矩阵 (Passability Matrix)

内存中维护着一个二维数组，存储每个格子的 Cost（代价），不仅仅是简单的 0 和 1：

  * **`0` (Base Cost)**：畅通无阻（平原、公路）。
  * **`Infinity` (Blocked)**：绝对不可通行（深水、悬崖、墙壁、建筑占据区）。
  * **`High Cost` (Soft Obstacle)**：难行地形（如沼泽、沙滩）。虽然可通行，但会显著增加 G 值，迫使 A\* 算法倾向于绕行，除非绕路成本极高。

#### 2.3 动态环境响应 (Dynamic Updates)

  * **实时刷新**：当玩家建造建筑（如炮塔）时，其占据的格子会**立即**从 `0` 刷新为 `Infinity`。
  * **事件触发**：`TileMap` 通过事件机制通知 `PathEngine`，标记相关区域的路径缓存为“失效 (Invalid)”，迫使移动中的单位在下一帧重新计算路径，从而实现“单位意识到前方突然多了一堵墙”的效果。

-----

### 3\. 调度层：PathEngine 的性能总控

#### 3.1 分时计算与时间切片 (Time-Slicing)

这是支持海量单位同屏的核心优化。

  * **帧限制**：引擎每一帧仅处理固定数量的寻路请求（例如 5-10 个）。
  * **排队机制**：如果 200 个单位同时下达移动指令，多余的请求会驻留在后台队列中。部分单位会“发呆”几帧等待轮到自己。这避免了 CPU 瞬时过载导致的画面卡死。

#### 3.2 优先级机制 (Priority Scheduling)

  * 并非所有请求都是平等的。高危单位（如正在交战的部队）或玩家当前屏幕焦点的单位，可被标记为 `isHighPriority`。
  * 源码体现为 `pathEngine.a(isHighPriority)`，这些请求会插队到队列前端优先处理。

#### 3.3 对象池模式 (Object Pooling)

Java 的垃圾回收 (GC) 是性能大敌，系统严禁在寻路循环中 `new` 对象。

  * **Node 池**：A\* 算法运算过程中产生的海量临时节点（Node）是从静态池中获取的。计算结束后，节点被重置并标记为“未使用”，而非被 GC 回收。
  * **Request 池**：`PathRequest` 对象本身也是复用的，避免了频繁创建销毁任务对象的开销。

#### 3.4 路径缓存与快速失败

  * **热点复用**：若多个单位（如编队）前往同一目标点，调度层会复用最近计算出的路径结果，仅做起点偏移微调。
  * **失败截断**：当目标点被完全围死（如被围墙包围），A\* 算法在搜索深度超过一定阈值后会**提前终止**，防止算法遍历整个地图从而导致严重卡顿。

-----

### 4\. 任务层：A\* 算法的具体实现

核心类 `PathEngine` 采用经典的启发式搜索，但在权重计算上进行了定制。

#### 4.1 算法公式

$$f(n) = g(n) + h(n)$$

#### 4.2 G(n)：实际代价与地形权重

$g(n)$ 是从起点到当前格子的累计成本，受 `UnitMovementType` 动态影响：

  * **基础移动**：`g = g_parent + 1`。
  * **难行地形**：例如坦克在泥地，`g = g_parent + 3`（成本显著增加）。
  * **类型过滤**：海军单位在陆地格子的成本直接被视为 `Infinity`。

#### 4.3 H(n)：启发函数的选择

  * **切比雪夫距离 (Chebyshev Distance)**：
    由于游戏允许 8 方向移动（包含对角线），系统主要使用此公式：
    $$h(n) = max(|dx|, |dy|)$$
    这比曼哈顿距离更贴近实际移动逻辑，减少了过度搜索。
  * 注：在仅允许 4 方向移动的特殊模式下，会回退到曼哈顿距离；标准空间计算使用欧几里得距离。

#### 4.4 多态移动类型枚举 (UnitMovementType)

不同单位使用不同的寻路规则表：

  * **LAND (陆军)**：标准模式，排除 `WATER` 和 `CLIFF`。
  * **HOVER (悬浮)**：排除 `CLIFF`，可穿越水陆。
  * **WATER (海军)**：仅保留 `WATER` 网格。
  * **AIR (空军)**：
      * **跳过 A**\*：直接采用直线移动 (Beeline) 逻辑。
      * **盘旋逻辑**：需处理最小转弯半径，不能像坦克一样原地旋转。
  * **OVER\_CLIFF (全地形)**：如蜘蛛机甲，视所有地形为低成本 (Cost=1)，可跨越悬崖。

-----

### 5\. 执行层：平滑处理与微观物理

有了 A\* 提供的路点列表，`OrderableUnit` 负责具体的“驾驶”工作。

#### 5.1 路径平滑 (String Pulling / Smoothing)

A\* 产出的路径是基于网格的折线（锯齿状）。为了让移动自然，系统引入了“视线检查 (Line of Sight)”机制。

**伪代码逻辑还原：**

```java
// 单位位于 currentPos，路径列表为 [wp1, wp2, wp3, ...]
// 尝试向前看更远的路点 (Look-ahead)

if (pathEngine.isPassable(movementType, currentPos, waypoint3)) {
    // 如果单位能直接直线走到 waypoint3 且中间无障碍
    targetPoint = waypoint3; // 直接跳过 waypoint1 和 waypoint2
    // 结果：单位走出了自然的切线/弧线，而不是死板地沿着格子走
} else if (pathEngine.isPassable(movementType, currentPos, waypoint2)) {
    targetPoint = waypoint2;
} else {
    targetPoint = waypoint1;
}
```

#### 5.2 状态机驱动的移动 (Steering)

单位每帧执行以下逻辑：

1.  **Angle Calculation**：计算当前坐标指向目标路点的角度。
2.  **Turning**：根据 `turnSpeed` 属性渐进旋转机身。
      * 重型单位（如猛犸坦克）转速慢，轻型单位转速快。
3.  **Acceleration**：当朝向误差小于阈值时，沿当前方向施加加速度，直至 `maxSpeed`。
4.  **Completion**：当 `distance(self, waypoint) < 阈值` 时，指针切换至下一路点。

#### 5.3 物理避让与软碰撞 (Soft Collision / RVO)

这是解决单位重叠的关键。动态避障**不使用** A\*（成本太高），而是基于物理推挤。

  * **碰撞模型**：每个单位拥有一个圆形碰撞体，半径为 `radius`。
  * **推挤力公式**：
    每帧检测周围单位，若 $d < (r_A + r_B)$，则施加反向排斥力：
    $$\vec{F}_{repulsion} = k \cdot \frac{(r_A + r_B - d)}{d} \cdot \vec{AB}$$
    其中 $k$ 为弹性系数。
  * **效果**：单位之间允许短暂重叠，表现出如流体般的顺滑挤压，而非刚体碰撞的“卡死”。
  * **队形控制 (Flocking)**：当选中多个单位移动时，系统会计算一个目标区域，并为每个单位分配该区域内的一个**独立偏移坐标 (Offset)**，防止所有单位挤向同一个像素点。

-----

### 6\. 总结：完整的寻路生命周期

从玩家点击到单位到达，系统的完整调用栈如下：

1.  **指令接收**：`OrderableUnit` 接收 Move 命令，计算群聚偏移量 (Offset)。
2.  **请求生成**：向 `PathEngine` 申请 `PathRequest` 对象（从对象池获取）。
3.  **排队调度**：请求进入后台线程队列，根据优先级和时间片等待处理。
4.  **核心计算**：后台线程执行 A\* 算法，结合地形权重 ($f=g+h$) 生成坐标链。
5.  **回调返回**：主线程接收路径结果。
6.  **微观执行 (每帧)**：
      * **平滑**：通过视线检查跳过冗余路点。
      * **转向与加速**：驱动单位物理位移。
      * **物理推挤**：计算 $\vec{F}_{repulsion}$ 避开友军。
