这是**第三部分：网络同步机制 (Network Synchronization Mechanism)** 的系统性翻译和逻辑拆解。

在RTS（即时战略）游戏中，网络同步是最复杂、最核心的技术壁垒。《铁锈战争》采用了业界标准的**确定性帧同步（Deterministic Lockstep）**模型。这意味着游戏并不直接同步每个单位的位置（那需要巨大的带宽），而是同步“玩家的操作指令”。

以下是基于源码分析的网络架构逻辑：

---

### 第三部分：网络同步与联机架构

#### 1. 核心指挥塔：网络引擎 (GameNetEngine)
在源码中（位于 `com.corrodinggames.rts.gameFramework.net` 包下，通常对应类 `GameNetEngine` 或 `ad`），这是处理所有多人联机逻辑的单例控制器。

* **双重身份 (Host & Client)**：
    * 代码逻辑中并没有严格区分“服务器版”和“客户端版”游戏。
    * **Host (主机)**：也是一个客户端，但它额外承担了“法官”的角色。它负责收集所有人的指令，决定当前是第几帧，并将指令包广播给所有人。
    * **Client (客户端)**：只负责发送自己的指令，并监听主机的广播。

* **传输协议 (Transport Layer)**：
    * 游戏混合使用了 **TCP** 和 **UDP**。
    * **TCP**: 用于握手、地图传输、聊天等如果不完整就会出错的数据。
    * **UDP (主要)**：用于高频的游戏指令同步。为了解决丢包问题，源码中实现了一套自定义的可靠 UDP 协议（类似 RUDP），包含 `AcknowledgmentPacket`（确认包）和 `ResetPacket`（重置包），确保指令一定送达且顺序正确。

#### 2. 帧同步核心流程 (The Lockstep Loop)
这是多人游戏“不卡顿、不瞬移”的秘密。

**A. 逻辑帧与渲染帧分离**
* **渲染帧 (FPS)**：你的显卡每秒画多少张图（比如 60 FPS）。
* **逻辑帧 (Turn/Tick)**：游戏内部逻辑更新的频率。代码中通常设定为每秒更新固定次数（例如 15次或 30次）。网络同步只在逻辑帧上进行。

**B. 预测与延迟执行 (Input Delay)**
当你在联机时点击“移动坦克”：
1.  **本地不立即执行**：坦克不会马上动。
2.  **打包发送**：你的点击被封装成一个 `GameCommand`，发送给主机。
3.  **主机定序**：主机收到你的指令，标记为“将在第 N+2 帧执行”，然后广播给所有玩家（包括你）。
4.  **全网执行**：当所有玩家的游戏时间都走到“第 N+2 帧”时，大家的引擎同时执行这个移动指令。
    * *结果*：因为大家的初始状态一样，执行的代码一样，所以坦克在每个人屏幕上的移动轨迹完全一致。

#### 3. 关键数据结构 (Key Data Structures)

* **GameCommand (指令包)**
    * 这是网络传输的最小单位。
    * **内容**: 包含 `commandType`（移动/建造/攻击）、`targetId`（目标单位ID）、`x, y`（坐标）、`checksum`（校验和）。
    * **序列化**: 使用了 `GameOutputStream` 类，将复杂的 Java 对象压缩成极小的二进制流（byte array），以节省带宽。

* **SyncPacket (同步帧)**
    * 主机每隔几十毫秒发送一次。
    * 它包含：当前帧号 (Turn ID) + 该帧发生的所有玩家指令列表。

#### 4. 反作弊与防不同步 (Anti-Desync System)
由于采用了帧同步，任何一点微小的计算误差（比如一个玩家算出来坦克剩 1 血，另一个算出来剩 0 血）都会导致“蝴蝶效应”，最终让两边游戏完全不一样（Desync）。

* **校验和 (Checksum)**
    * **逻辑**: 游戏会定期（例如每 100 帧）对整个游戏世界拍一张“快照”，计算所有单位的位置、血量、状态的 Hash 值。
    * **比对**: 客户端将自己的 Hash 值发给主机。如果主机发现某人的 Hash 与自己不同，就会判定发生“不同步 (Desync)”，并在屏幕上弹出那个让所有玩家心惊肉跳的红色警告：“Game Desync Detected”。

* **确定性算法 (Determinism)**
    * 源码中严禁使用 Java 自带的 `Math.random()` 或 `float` 的不确定运算。
    * **自定义随机数**: 游戏实现了一个 `SeededRandom` 类。只要种子（Seed）一样，第 N 次调用的随机结果永远一样。开局时主机把种子发给所有人，保证大家的暴击、伤害浮动完全一致。

#### 5. 断线重连与追帧 (Reconnection & Catch-up)
如果有人掉线了怎么办？

* **Resync (重同步)**
    * 掉线玩家重新加入时，他错过了中间的几千帧指令。
    * **快照传输**: 主机暂停游戏，将当前的完整游戏状态（所有单位对象序列化）打包压缩，通过 TCP 发送给掉线玩家。
    * **加载**: 掉线玩家收到后，直接覆盖本地内存，瞬间“穿越”到当前战局。

---

### 第三部分逻辑总结图示

你可以想象一个**多线程的流水线**：

1.  **Input (玩家操作)** -> 封装为 `Packet` -> **Network Queue (网络队列)**。
2.  **Send (发送)** -> 互联网 -> **Host (主机)**。
3.  **Host Process (主机处理)** -> 收集所有人的包 -> 打包成 `Frame Packet` -> 广播。
4.  **Receive (接收)** -> 客户端收到 `Frame Packet` -> **Command Buffer (指令缓冲池)**。
5.  **Execution (执行)** -> 游戏主循环运行到第 X 帧 -> 从缓冲池取出标记为 X 帧的指令 -> **UnitController (单位控制器)** 执行。

这就是为什么联机时网络卡顿不是“画面卡成幻灯片”，而是“单位对命令反应迟钝（延迟高）”或者“所有单位原地踏步（丢包等待中）”。
